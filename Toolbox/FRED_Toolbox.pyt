# -*- coding: utf-8 -*-import arcpyimport mathimport pathlib as ptlibimport tempfileimport statisticsfrom datetime import datetimeimport numpyimport numpy as npimport pandas as pdimport rasterioimport scipy.constantsfrom rasterio import windowsfrom rasterio import plot# OGR is used for Vector Datafrom osgeo import ogr# GDAL is used for Raster Datafrom osgeo import gdalfrom osgeo import gdalconstimport matplotlib.pyplot as pltimport timeimport osimport shutilimport pandasimport reimport shapely.geometryimport randomfrom rasterio import mask, warpimport jsonfrom scipy import constantsimport globarcpy.env.overwriteOutput = Truearcpy.env.addOutputsToMap = Trueclass Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [Radiance_to_Kelvin, FRED_and_FRFD_Calculator, Binary_Classifiers]class Radiance_to_Kelvin:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Huh Kelvin Converter"        self.description = "Prior to calculating FRED, the user must convert their radiance values to Kelvin. Plancks function is used for conversions" + \            "The user must know the central wavelength of the thermal infrared band they are using prior to running this function" + \            "Output is a folder with a Kelvin raster stack that can be used for FRED/FRFD calculations"    def getParameterInfo(self):        """Define the tool parameters."""        # To edit parameter descriptions, you must edit the associated XML file        params = []        # Central wavelength for Plancks Function        Central_Wavelength = arcpy.Parameter(            displayName="Central Wavelength",            name="central_wavelength",            datatype="GPDouble",            parameterType="Required",            direction="Input")        Radiance_Offset = arcpy.Parameter(            displayName="Radiance Offset",            name="radiance_offset",            datatype="GPDouble",            parameterType="Required",            direction="Input")        # Input directory containing radiance mosaics        Input_Raster_Directory = arcpy.Parameter(            displayName="Input Rasters",            name="input_rasters",            datatype="DEFolder",            parameterType="Required",            direction="Input")        # Output location for Kelvin mosaics        # When the function runs, the output directory will contain a new folder for kelvin mosaics        Output_Directory = arcpy.Parameter(            displayName="Output Location",            name="output_location",            datatype="DEFolder",            parameterType="Required",            direction="Input")        params.append(Output_Directory)        params.append(Central_Wavelength)        params.append(Input_Raster_Directory)        params.append(Radiance_Offset)        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    # All functions will be run in this method    # Convert radiance to Kelvin    def execute(self, parameters, messages):        """The source code of the tool."""        # This is where the conversion code goes        # Establish temporary directory to store individual kelvin mosaics        temporary_directory = tempfile.mkdtemp()        # Initialize parameters as text for functions        input_raster_location = parameters[2].ValueAsText        central_wavelength = float(parameters[1].ValueAsText)        output_location = parameters[0].ValueAsText        radiance_off = float(parameters[3].ValueAsText)        def Plancks_Function(Array, w, off):            """            Plancks function that converts radiances to Kelvin            :param Array:            :return:            """            # Outputs Kelvin            L = Array.astype(float) / off            c1 = 1.1910E8            c2 = 1.439E4            T = (c2) / (w * (np.log((c1 / ((w ** 5) * L)) + 1)))            T[(T == float("inf"))] = 0            print(T.max())            return T        def __List_Rasters(Path, file_type="tif"):            path = ptlib.Path(Path)            All_Rasters = list(path.glob('**/*.{}'.format(file_type)))            Raster_List = []            for raster in All_Rasters:                Raster_Path = str(raster).replace("/", "\\")                Raster_List.append(Raster_Path)            return Raster_List        def Temperature_Rasters(raster_path, output_location, w, off):            rasters = __List_Rasters(raster_path)            if len(rasters) > 1:                for i in range(0, len(rasters)):                    file_name = os.path.basename(rasters[i])                    # Grab the pass number from the file name                    image_n = file_name[0:5]                    raster = rasterio.open(rasters[i])                    out_meta = raster.meta                    array = raster.read(1)                    Temp_array = Plancks_Function(                        off = off,                        Array=array,                        w=w)                    out_meta.update({'dtype': "float32"})                    with rasterio.open("{}/{}_Float.tif".format(output_location, image_n), 'w', **out_meta) as dst:                        dst.nodata = None                        dst.write(Temp_array, 1)            else:                file_name = os.path.basename(rasters[0])                # Grab the pass number from the file name                image_n = file_name[0:2]                raster = rasterio.open(rasters[0])                out_meta = raster.meta                array = raster.read(1)                Temp_array = Plancks_Function(                    off = off,                    Array=array,                    w=w)                out_meta.update({'dtype': "float32"})                with rasterio.open("{}/{}_Float.tif".format(output_location, image_n), 'w', **out_meta) as dst:                    dst.nodata = None                    dst.write(Temp_array, 1)        def Raster_Stack(output_location, raster_path):            temp = tempfile.mkdtemp()            try:                # Open each raster in the list of rasters                rasters = __List_Rasters(raster_path)                # Compare the extents of the first two rasters and create a new raster with their overlapping bounding box                intersection = None                with rasterio.open(rasters[0]) as r_1, rasterio.open(rasters[1]) as r_2:                    ext1 = shapely.geometry.box(*r_1.bounds)                    ext2 = shapely.geometry.box(*r_2.bounds)                    # Determine intersection for first two rasters                    intersection = ext1.intersection(ext2)                for i in range(2, len(rasters)):                    # Determine intersection for each raster until the extent at which all rasters intersect will be identified and used for                    r = rasterio.open(rasters[i])                    ext_1 = shapely.geometry.box(*intersection.bounds)                    ext_2 = shapely.geometry.box(*r.bounds)                    # Update the intersection variable over time                    intersection = ext_1.intersection(ext_2)                # Use the intersection to clip the first raster. Use the metadata and transform from that clipped raster as the                # Base raster is the clipped raster with the new extent and transformed with the transform from the mask output                geom = shapely.geometry.mapping(intersection)                n = 0                out_meta = None                location_list = []                for r in rasters:                    n += 1                    src = rasterio.open(r)                    ra = src.read(1)                    out_meta = src.meta                    clip_image, clip_transform = rasterio.mask.mask(src, [geom], crop=True)                    out_meta.update({"height": clip_image.shape[1],                                     "width": clip_image.shape[2],                                     "transform": clip_transform})                    with rasterio.open("{}/C_{}.tif".format(temp, n), "w", **out_meta) as new:                        new.write(clip_image)                    location_list.append("{}/C_{}.tif".format(temp, n))                    src = None                out_meta.update({'count': len(rasters)})                n = 0                with rasterio.open("{}/Kelvin_Stack.tif".format(output_location), 'w', **out_meta) as src_1:                    for l in location_list:                        n += 1                        src_2 = rasterio.open(l)                        src_1.write(src_2.read(1), n)            except Exception as e:                temp = None                raster = None                print(e)        arcpy.AddMessage("Converting Radiances to Kelvins")        Temperature_Rasters(off = radiance_off,            raster_path=input_raster_location,            output_location=temporary_directory,            w=central_wavelength)        arcpy.AddMessage("Stacking rasters to create Kelvin raster stack")        Raster_Stack(            output_location=output_location,            raster_path=temporary_directory)        shutil.rmtree(temporary_directory)        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""class FRED_and_FRFD_Calculator:    def __init__(self):        self.label = "FRED and FRFD Calculator"        self.description = ""    def getParameterInfo(self):        """Define the tool parameters."""        # To edit parameter descriptions, you must edit the associated XML file        params = []        # Input_Raster_Directory        Input_Raster_Directory = arcpy.Parameter(            displayName="Input Rasters",            name="input_raster",            datatype="DERasterDataset",            parameterType="Required",            direction="Input")        Ambient_Temperature = arcpy.Parameter(displayName="Ambient Temperature",            name="ambient_temp",            datatype="GPString",            parameterType="Required",            direction="Input")        Pass_Time_Table = arcpy.Parameter(displayName = "Pass Time Table",                                           name = "pass_time_table",                                           datatype = "DETable",                                           parameterType="Required",                                           direction = "Input")        Image_Pass_Times = arcpy.Parameter(displayName = "Image Pass Time Field",                                           name = "image_pass_times",                                           datatype = "GPString",                                           parameterType="Required",                                           direction = "Input",                                           multiValue = True)        Output_Directory = arcpy.Parameter(displayName="Output Location",                                           name="output_location",                                           datatype="DEFolder",                                           parameterType="Required",                                           direction="Input")        Peak_FRFD = arcpy.Parameter(displayName="Peak FRFD Raster",                                    name="Peak_FRFD_Raster",                                    datatype="GPBoolean",                                    parameterType="Optional",                                    direction="Input")        Image_Pass_Times.enabled = False        Ambient_Temperature.value = 289        params = [Input_Raster_Directory, Ambient_Temperature, Pass_Time_Table, Image_Pass_Times, Output_Directory, Peak_FRFD]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        if parameters[2].altered == True:            parameters[3].enabled = True            times = parameters[2].ValueAsText            flds = [f.name for f in arcpy.ListFields(times)]            parameters[3].filter.list = flds    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        # This is where the conversion code goes        # Create scratch folder for separated FRFDs        # Use os.path.join with this location when calculating FRFD        frfd_temp = arcpy.env.scratchFolder        # Load the parameters as text        input_raster = parameters[0].ValueAsText        ambient_temperature = parameters[1].ValueAsText        pass_time_table = parameters[2].ValueAsText        image_pass_time = parameters[3].ValueAsText        out_put_path = parameters[4].ValueAsText        arcpy.AddMessage(out_put_path)        FRED_output_location = os.path.join(out_put_path + '\FRED')        if os.path.exists(FRED_output_location):            filelist = os.listdir(FRED_output_location)            if len(filelist) >= 0:                for f in filelist:                    os.remove(os.path.join(FRED_output_location, f))            os.rmdir(FRED_output_location)            os.mkdir(FRED_output_location)        else:            os.mkdir(FRED_output_location)        FRFD_output_location = os.path.join(out_put_path + '\FRFD_Stack')        if os.path.exists(FRFD_output_location):            filelist = os.listdir(FRFD_output_location)            if len(filelist) >= 0:                for f in filelist:                    os.remove(os.path.join(FRFD_output_location, f))            os.rmdir(FRFD_output_location)            os.mkdir(FRFD_output_location)        else:            os.mkdir(FRFD_output_location)        FRFDs_output_location = os.path.join(out_put_path + '\FRFD_Rasters')        if os.path.exists(FRFDs_output_location):            filelist = os.listdir(FRFDs_output_location)            arcpy.AddMessage(filelist)            if len(filelist) >= 0:                for f in filelist:                    os.remove(os.path.join(FRFDs_output_location, f))            os.rmdir(FRFDs_output_location)            os.mkdir(FRFDs_output_location)        else:            os.mkdir(FRFDs_output_location)        # Load the raster as an arcpy raster object        kelvin_raster = arcpy.sa.Raster(input_raster)        # Get the band count from the Kelvin Raster and create a loop to extract the band        bands = kelvin_raster.bandCount        # Create list of Raster objects that will be used for calculations        kelvin_rasters = []        for b in range(1, bands+1):            # Extract an individual band from the raster            single_raster = arcpy.ia.ExtractBand(kelvin_raster, [b])            kelvin_rasters.append(single_raster)        # With the list of raster objects, calculate FRFD        # I guess just use arithmetic and append to list?        FRFD_Rasters = []        s = scipy.constants.sigma        FRFD_Raster_Locations = []        at = int(ambient_temperature)        # Consider creating output statistics for FRED and FRFD Rasters        for i in range(0, len(kelvin_rasters)):            r = arcpy.Raster(kelvin_rasters[i])            reclass_range = arcpy.sa.RemapRange([[r.minimum, r.maximum, at]])            reclass_ambient = arcpy.sa.Reclassify(kelvin_rasters[i], remap=reclass_range, reclass_field="VALUE")            arcpy.AddMessage(reclass_ambient.minimum)            arcpy.AddMessage(reclass_ambient.maximum)            frfd_raster = s*(r**4 - reclass_ambient**4)            FRFD_Rasters.append(frfd_raster)            # Output Raster Location            FRFD_Raster_Locations.append("{}/{}".format(FRFDs_output_location, 'FRFD_{}.tif'.format(i+1)))            arcpy.AddMessage("{}".format(arcpy.Raster(FRFD_Rasters[i]).maximum))            frfd_raster.save("{}/{}".format(FRFDs_output_location, 'FRFD_{}.tif'.format(i+1)))            del frfd_raster            del r            del reclass_ambient        del kelvin_rasters        # After calculating FRFD, get the pass times for FRED calculations        pass_times = []        # Create a Search Cursor to retrieve values from a specific attribute in the table        with arcpy.da.SearchCursor(pass_time_table, [image_pass_time]) as cursor:            for row in cursor:                pass_times.append(row[0])        # Adapt FRED function based on raster calculator        # First, create a loop that includes the two rasters, as well as the pass times converted into time past (seconds).        FREDs = []        arcpy.AddMessage(len(FRFD_Rasters))        arcpy.AddMessage(len(pass_times))        arcpy.AddMessage(pass_times)        for d in range(1, len(FRFD_Rasters)):            # Collect the current date. To do subtractions between times you need a date            date = datetime.now().date()            # First time            t1 = datetime.combine(date, pass_times[d-1])            # Second time            t2 = datetime.combine(date, pass_times[d])            arcpy.AddMessage("{}".format(d))            #Time change            delta = t2-t1            # Calculate the sum of two FRFD Rasters            FRFD_Sum = (FRFD_Rasters[d] + FRFD_Rasters[d-1])            # Calculate FRED            FRED = ((FRFD_Sum) * delta.seconds) * 0.5            del FRFD_Sum            FREDs.append(FRED)            del FRED        # Establish a base raster for calculations        total_fred = FREDs[0]        # Calculate the FRED by summing all FRED calculations (trapezoids)        for f in FREDs[1:]:            total_fred = arcpy.sa.Plus(f, total_fred)        arcpy.AddMessage("FRED has been calculated")        del FREDs        # Save the output FRED raster to the identified location        total_fred.save(os.path.join(FRED_output_location, "FRED_{}.tif".format(ambient_temperature)))        arcpy.AddMessage("FRED has been exported")        del total_fred        # Create output string for composite band raster function        if parameters[5].value:            # Calculate the maximum value for all FRFD rasters            max_frfd = arcpy.ia.Max(FRFD_Raster_Locations, extent_type="IntersectionOf", cellsize_type="FirstOf")            arcpy.AddMessage("Peak FRFD has been calculated")            # Save the Max FRFD raster            max_frfd.save(os.path.join(FRFD_output_location, "Peak_FRFD_{}.tif".format(ambient_temperature)))            arcpy.AddMessage("Peak FRFD has been exported")            del max_frfd            # Determine the image pass when the maximum pixel value was reached            max_frfd_time = arcpy.ia.HighestPosition(rasters=FRFD_Raster_Locations, extent_type="IntersectionOf", cellsize_type="FirstOf")            # Save the maximum frfd time value            max_frfd_time.save(os.path.join(FRFD_output_location, "Peak_FRFD_Time_{}.tif".format(ambient_temperature)))            del max_frfd_time            # Create the FRFD Stack            arcpy.CompositeBands_management(in_rasters=";".join(FRFD_Raster_Locations), out_raster="{}/{}".format(FRFD_output_location, "FRFD_{}.tif".format(ambient_temperature)))        else:            # If the Peak FRFD option is not checked, only the output stack will be provided.            # Users can calculate the maximum frfd and time on their own.            arcpy.CompositeBands_management(in_rasters=";".join(FRFD_Raster_Locations),                                            out_raster="{}/{}".format(FRFD_output_location,                                            "FRFD_{}".format(ambient_temperature)))        arcpy.AddMessage("FRFD stack has been exported")    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""class Binary_Classifiers:    def __init__(self):        self.label = "Binary Classifer"        self.description = "Classifies individual pixels based on their temporal characteristics. Includes 3 classifcations: Burned, Completed, Obscured"    def getParameterInfo(self):        """Define the tool parameters."""        # To edit parameter descriptions, you must edit the associated XML file        Input_Temp_Raster = arcpy.Parameter(            displayName="Peak FRFD Raster",            name="temp_raster",            datatype="DERasterDataset",            parameterType="Required",            direction="Input")        Input_FRFD_Raster = arcpy.Parameter(            displayName="Input FRFD Raster",            name="frfd_raster",            datatype="DERasterDataset",            parameterType="Required",            direction="Input")        Pass_Time_Table = arcpy.Parameter(displayName="Pass Time Table",                                          name="pass_time_table",                                          datatype="DETable",                                          parameterType="Required",                                          direction="Input")        Image_Pass_Times = arcpy.Parameter(displayName="Image Pass Time Field",                                           name="image_pass_times",                                           datatype="GPString",                                           parameterType="Required",                                           direction="Input",                                           multiValue=True)        Burned_Temperature = arcpy.Parameter(displayName="Minimum Burn Temperature",            name="burn_temp",            datatype="GPString",            parameterType="Required",            direction="Input")        Complete_Percentage = arcpy.Parameter(displayName="Complete Profile Percentage",                                             name="complete_prof",                                             datatype="GPString",                                             parameterType="Required",                                             direction="Input")        Obscuration_Percentage = arcpy.Parameter(displayName="Obscuration Percentage",                                             name="obscur_percentage",                                             datatype="GPString",                                             parameterType="Required",                                             direction="Input")        Output_Directory = arcpy.Parameter(displayName="Output Location",                                           name="output_location",                                           datatype="DEFolder",                                           parameterType="Required",                                           direction="Input")        Complete_Percentage.value = 95        Obscuration_Percentage.value = 40        Burned_Temperature.value = 473        params = [Input_Temp_Raster, Input_FRFD_Raster, Burned_Temperature, Complete_Percentage, Obscuration_Percentage, Pass_Time_Table, Image_Pass_Times, Output_Directory]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        if parameters[5].altered == True:            parameters[6].enabled = True            times = parameters[5].ValueAsText            flds = [f.name for f in arcpy.ListFields(times)]            parameters[6].filter.list = flds        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        parameters[3].clearMessage()        parameters[4].clearMessage()        if parameters[3].value:            if int(parameters[3].value) > 100:                parameters[3].setErrorMessage("Percentage value is greater than 100%. Value must be lower than 100%")        if parameters[4].value:            if int(parameters[4].value) > 100:                parameters[4].setWarningMessage("Percetange value is greater than 100%")        return    def execute(self, parameters, messages):        """The source code of the tool."""        # This is where classifier code goes        # Create multiple classifier functions        # First use the burning classifier        # then use the completion classifier        # THen use the obscuration classifier        # Output the parameter values as inputs for the other functions        def Create_Output_Binary_Raster(raster_info, array, output_location, raster_name):            "Output raster through GDAL"            # Create data source            driver_tiff = gdal.GetDriverByName("GTiff")            driver_tiff.Register()            file_path_output = "{}/{}".format(output_location, raster_name)            geotransform = raster_info["geotransform"]            cols = raster_info["cols"]            rows = raster_info["rows"]            projection = raster_info["projection"]            metadata = raster_info["metadata"]            create_output = driver_tiff.Create(file_path_output, cols, rows, 1, gdal.GDT_Int8)            band = create_output.GetRasterBand(1)            band.WriteArray(array)            create_output.SetProjection(projection)            create_output.SetGeoTransform(geotransform)            create_output.SetMetadata(metadata)        def Get_Raster_Info(raster):            "Extract raster information through GDAL"            r = gdal.Open(raster)            cols = r.RasterXSize            rows = r.RasterYSize            bands = r.RasterCount            geotransform = r.GetGeoTransform()            projection = r.GetProjection()            metadata = r.GetMetadata()            raster_info = {                'cols': cols,                'rows': rows,                'bands': bands,                'projection': projection,                'metadata': metadata,                'geotransform':geotransform            }            return raster_info        def Burning_Classifier(raster, min_temp, output_location):            s = scipy.constants.sigma            # Creates output array and raster            # Use the output from this classifier for the next classifiers            # Take a raster object and reclass it through the reclassify tool in ArcPy            file_name = os.path.basename(raster)            at = int(file_name[10:13])            min_frfd = s*(min_temp**4 - at**4)            r = arcpy.Raster(raster)            reclass_range = arcpy.sa.RemapRange([[r.minimum, min_frfd, 0], [min_frfd, r.maximum, 1], ['NoData','NoData', 0]])            burn_reclass = arcpy.sa.Reclassify(in_raster=raster,                                reclass_field='value',                                remap=reclass_range)            save_location = "{}/burn_raster_{}.tif".format(output_location, min_temp)            burn_reclass.save(save_location)            return save_location        def Complete_Classifier(burn_raster, raster, percentage, time, output_location):            # Creates output array and raster            # Analyze the shape of each individual profile            # Create an output raster name for the binary classifier            output_name = f"Complete_Class_{percentage}.tif"            raster_info = Get_Raster_Info(raster)            br_raster_info = Get_Raster_Info(burn_raster)            arcpy.AddMessage(raster_info)            arcpy.AddMessage(br_raster_info)            # Create list to store list of band arrays            array_list = []            cols = raster_info["cols"]            rows = raster_info["rows"]            # Open frfd raster            r = gdal.Open(raster)            # Open burn raster            br = gdal.Open(burn_raster)            # Iterate through every band in FRFD raster            for i in range(1, raster_info["bands"] + 1):                b = r.GetRasterBand(i)                array_list.append(b.ReadAsArray(0,0,cols,rows))            # Create stack of arrays            r_stack = np.dstack(array_list)            del array_list            # Create burn raster array            b = br.GetRasterBand(1)            br_array = b.ReadAsArray(0,0, br_raster_info['cols'], br_raster_info['rows'])            # Create empty array for populating classified values            class_array = np.zeros_like(br_array)            # Iteratre through each pixel            for i in range(0, rows):                for j in range(0, cols):                    if br_array[i][j] == 0:                        class_array[i][j] = 0                    else:                        FRFD_stack = r_stack[i][j]                    # Create list for cumulative FRED                        Cumulative_FRED = []                        Cumulative_FRED_Percent = []                        FRED_List = []                        Tot_FRED = 0                        for f in range(1, len(FRFD_stack)):                            FRFD_2 = FRFD_stack[f]                            # Call the first FRFD array                            FRFD_1 = FRFD_stack[f - 1]                            # Call the first Time in the list                            date = datetime.now().date()                            # First time                            t1 = datetime.combine(date, time[f - 1])                            # Second time                            t2 = datetime.combine(date, time[f])                            # Get the difference between the two time classes                            delta = t2 - t1                            # Sum up the FRFD calculations                            FRFD_Sum = (FRFD_2 + FRFD_1)                            # Any values less than 0 are converted to 0 (pixels that have temperatures below ambient                            if FRFD_Sum <= 0:                                FRFD_Sum = 0                            # Calculate the FRED and add it to the FRED list                            FRED = ((FRFD_Sum) * delta.seconds) * 0.5                            Tot_FRED += FRED                            Cumulative_FRED.append(Tot_FRED)                            FRED_List.append(FRED)                        # Calculate Cumulative FRED Percent                        Total_FRED = sum(FRED_List)                        for fr in Cumulative_FRED:                            Cumulative_FRED_Percent.append((fr/Total_FRED) * 100)                        if Cumulative_FRED_Percent[len(Cumulative_FRED_Percent) - 2] > percentage:                            class_array[i][j] = 1                        else:                            class_array[i][j] = 0            Create_Output_Binary_Raster(raster_info=br_raster_info,                                        array = class_array,                                        output_location=output_location,                                        raster_name=output_name)            class_raster_data_source = f"{output_location}/{output_name}"            # Use the returned array as the complete raster for the obscuration classifier            return class_raster_data_source        def Obscuration_Classifier(complete_raster, raster, obscuration_percentage, output_location):            # Create output name for raster            output_name = f"Obscuration_Class_{obscuration_percentage}.tif"            # Creates output array and raster            raster_info = Get_Raster_Info(raster)            br_raster_info = Get_Raster_Info(complete_raster)            array_list = []            cols = raster_info["cols"]            rows = raster_info["rows"]            # Open frfd raster            r = gdal.Open(raster)            # Open burn raster            co = gdal.Open(complete_raster)            # Iterate through every band in FRFD raster            for i in range(1, raster_info["bands"] + 1):                b = r.GetRasterBand(i)                array_list.append(b.ReadAsArray(0, 0, cols, rows))            # Create stack of arrays            r_stack = np.dstack(array_list)            del array_list            # Create burn raster array            b = co.GetRasterBand(1)            c_array = b.ReadAsArray(0, 0, br_raster_info['cols'], br_raster_info['rows'])            # Create empty array for populating classified values            class_array = np.zeros_like(c_array)            for i in range(0, rows):                for j in range(0, cols):                    # If the profile is not complete, the pixel is classified as 0 for obscured                    if c_array[i][j] == 0:                        class_array[i][j] = 0                    else:                        # If it is a complete profile, the profile is extracted from the dstack                        FRFD_stack = r_stack[i][j]                        # Extract the peak profile portion of the temporal profile based on the location of the max FRFD                        Percents = []                        Peak_Profile = FRFD_stack[np.where(FRFD_stack == FRFD_stack.max())[0][0]:]                        for d in range(1, len(Peak_Profile)):                            # Call the first FRFD                            FRFD_1 = Peak_Profile[d-1]                            # Call the second FRFD                            FRFD_2 = Peak_Profile[d]                            # Calculate the percent change between the two (should be negative)                            percent_change = ((FRFD_2 - FRFD_1)/(FRFD_1)) * 100                            Percents.append(percent_change)                        if max(Percents) > obscuration_percentage:                            if np.array(max(Percents)) == np.inf:                                class_array[i][j] = 0                            else:                                class_array[i][j] = 1                        else:                            class_array[i][j] = 0            Create_Output_Binary_Raster(raster_info=br_raster_info,                                        array=class_array,                                        output_location=output_location,                                        raster_name=output_name)        # Call all parameters        temp_raster = parameters[0].ValueAsText        frfd_raster = parameters[1].ValueAsText        burned_temp = int(parameters[2].ValueAsText)        complete_percent = int(parameters[3].ValueAsText)        obscuration_percent = int(parameters[4].ValueAsText)        time_table = parameters[5].ValueAsText        image_pass_time = parameters[6].ValueAsText        output_location = parameters[7].ValueAsText        # Create folder for saving files        Binary_Classifier_location = os.path.join(output_location + "/Binary_Classifiers")        # If the folder already exists delete the files and recreate the directory        if os.path.exists(Binary_Classifier_location):            filelist = os.listdir(Binary_Classifier_location)            if len(filelist) >= 0:                for f in filelist:                    os.remove(os.path.join(Binary_Classifier_location, f))            os.rmdir(Binary_Classifier_location)            os.mkdir(Binary_Classifier_location)        else:            os.mkdir(Binary_Classifier_location)        # Create list of times for the classifiers        pass_times = []        # Create a Search Cursor to retrieve values from a specific attribute in the table        with arcpy.da.SearchCursor(time_table, [image_pass_time]) as cursor:            for row in cursor:                pass_times.append(row[0])        # Run the burn classifier and call the burn classified raster source        arcpy.AddMessage("Running Burn Classifier")        burn_source = Burning_Classifier(raster = temp_raster,                           min_temp=burned_temp,                           output_location=Binary_Classifier_location)        arcpy.AddMessage("Burn Classifier Complete")        # Run the completion classifier and call the completion source        arcpy.AddMessage("Running Complete Classifier")        completion_source = Complete_Classifier(burn_raster=burn_source,                                                raster=frfd_raster,                                                percentage=complete_percent,                                                time=pass_times,                                                output_location=Binary_Classifier_location)        arcpy.AddMessage("Complete Classifier Complete")        del burn_source        del pass_times        arcpy.AddMessage("Running Obscuration Classifier")        Obscuration_Classifier(complete_raster=completion_source,                               raster=frfd_raster,                               obscuration_percentage=obscuration_percent,                               output_location=Binary_Classifier_location)        arcpy.AddMessage("Obscuration Classifier Complete")